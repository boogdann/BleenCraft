;               
;              proc Field.Initialize
proc Field.Initialize uses edi
    
    mov al, 1
    mov edi, Field.Blocks
    mov ecx, 100
    rep stosb
    
.Iterate_Z:

.Iterate_Y:

.Iterate_X:
    
    stdcall Field.SetBlockIndex, 12, 12, 5, Blocks.STONE
    stdcall Field.SetBlockIndex, 13, 12, 5, Blocks.STONE 
    stdcall Field.SetBlockIndex, 14, 12, 5, Blocks.STONE
    stdcall Field.SetBlockIndex, 13, 12, 6, Blocks.STONE
    stdcall Field.SetBlockIndex, 13, 12, 7, Blocks.STONE
    
    stdcall Field.SetBlockIndex, 12, 12, 12, Blocks.STONE
    stdcall Field.SetBlockIndex, 13, 12, 12, Blocks.STONE 
    stdcall Field.SetBlockIndex, 14, 12, 12, Blocks.STONE
    stdcall Field.SetBlockIndex, 13, 12, 13, Blocks.STONE
    stdcall Field.SetBlockIndex, 13, 12, 14, Blocks.STONE
    
    stdcall Field.SetBlockIndex, 10, 10, 2, Blocks.STONE
    stdcall Field.SetBlockIndex, 11, 10, 2, Blocks.STONE 
    stdcall Field.SetBlockIndex, 12, 10, 2, Blocks.STONE
    stdcall Field.SetBlockIndex, 11, 10, 3, Blocks.STONE
    stdcall Field.SetBlockIndex, 11, 10, 4, Blocks.STONE    

.Finish:
    ret
endp

;              func Field.GetBlockIndex
;    Input:  dWord X, dWord Y, dWord Z
;    Output: eax <- BlockIndex or ErrorCode
;
proc Field.GetBlockIndex uses edi, X: word, Y: word, Z: word
;     stdcall Field.TestBounds, word[X], word[Y], word[Z]  
     cmp    eax, ERROR_OUT_OF_BOUND
     jz     .Finish   
     xor    eax, eax
     
     movzx  edi, word[Y]  
     imul   eax, edi, Field.LENGTH
     movzx  edi, word[X]
     add    eax, edi
     mul    word[Z]
     add    eax, Field.Blocks
     
     xchg   eax, edi
     movzx  eax, byte[edi]
     jmp    .Finish

.Finish:
     ret
endp

;              func Field.SetBlockIndex
;    Input:  Word X, Word Y, Word Z, byte BlockIndex
;    Output: eax <- BlockIndex or ErrorCode
;
proc Field.SetBlockIndex uses edi eax esi ecx, X: dword, Y: dword, Z: dword, BlockIndex: byte
;     stdcall Field.TestBounds, word[X], word[Y], word[Z]     
     cmp    eax, ERROR_OUT_OF_BOUND
     jz     .Finish 
     
     xor    eax, eax

     movzx  edi, word[Y]  
     imul   eax, edi, Field.LENGTH
     movzx  edi, word[X]
     add    eax, edi
     
     movzx  esi, word[Z]
     imul   ecx, esi, Field.LENGTH*Field.WIDTH 
     add    eax, ecx

     add    eax, Field.Blocks
     
     xchg   eax, edi
     movzx  eax, byte[BlockIndex]
     mov    byte[edi], al

     jmp    .Finish
.Finish:
     ret
endp

;              func Field.TestBounds
;    Input:  Word X, Word Y, Word Z
;    Output: eax <- Zero or ErrorCode
;
proc Field.TestBounds uses ebx, X: dword, Y: dword, Z: dword
     xor    eax, eax

     cmp    word[X], Field.LENGTH
     jge    .Error

     cmp    word[Y], Field.WIDTH
     jge    .Error

     cmp    word[Z], Field.HEIGHT
     jge    .Error

     cmp    word[X], 0
     jl     .Error 
     cmp    word[Y], 0
     jl     .Error
     cmp    word[Z], 0
     jl     .Error
     jmp    .Finish

.Error:    
     mov    eax, ERROR_OUT_OF_BOUND    
.Finish:   
     ret
endp