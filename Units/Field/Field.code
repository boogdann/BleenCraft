;               
;              proc Field.Initialize
proc Field.Initialize

;    ВРЕМЕННАЯ РЕАЛИЗАЦИЯ
;    create stone (hight 0 - 9)
     mov    ecx, 9
     mov    edi, Field.Blocks
.IterateLayers:
     push   ecx
     mov    ecx, Field.Length
.IterateLine:
    push    ecx
    mov     ecx, Field.Width
    mov     al,  Stone
    rep stosw
    pop     ecx 
    loop    .IterateLine
    pop     ecx
    loop    .IterateLayers     

;   create dirt (hight 10)

    mov     ecx, Field.Length
.IterateLineDirt:
    push    ecx
    mov     ecx, Field.Width
    mov     al,  Dirt
    rep stosw
    pop     ecx 
    loop    .IterateLineDirt 
    
;    create air (11-19)
     mov    ecx, 9
     mov    edi, Field.Blocks
.IterateLayersAir:
     push   ecx
     mov    ecx, Field.Length
.IterateLineAir:
    push    ecx
    mov     ecx, Field.Width
    mov     al,  Air
    rep stosw
    pop     ecx 
    loop    .IterateLineAir
    pop     ecx
    loop    .IterateLayersAir
    
    stdcall Field.SetBlockIndex, 12, 12, 12, Stone
    stdcall Field.SetBlockIndex, 13, 12, 12, Stone 
    stdcall Field.SetBlockIndex, 14, 12, 12, Stone
    stdcall Field.SetBlockIndex, 13, 12, 13, Stone
    stdcall Field.SetBlockIndex, 13, 12, 14, Stone
.Finish:
    ret
endp

;              func Field.GetBlockIndex
;    Input:  dWord X, dWord Y, dWord Z
;    Output: eax <- BlockIndex or ErrorCode
;
proc Field.GetBlockIndex uses edi, X: dword, Y: dword, Z: dword
     stdcall Field.TestBounds, dword[X], dword[Y], dword[Z]  
     cmp    eax, ERROR_OUT_OF_BOUND
     jz     .Finish   

     imul   eax, dword[Y], Field.Width
     add    eax, dword[X]
     mul    dword[Z]
     add    eax, Field.Blocks
     
     xchg   eax, edi
     movzx  eax, byte[edi]
     jmp    .Finish

.Finish:
     ret
endp

;              func Field.SetBlockIndex
;    Input:  dWord X, dWord Y, dWord Z, byte BlockIndex
;    Output: eax <- BlockIndex or ErrorCode
;
proc Field.SetBlockIndex uses edi, X: dword, Y: dword, Z: dword, BlockIndex: byte
     stdcall Field.TestBounds, dword[X], dword[Y], dword[Z]     
     cmp    eax, ERROR_OUT_OF_BOUND
     jz     .Finish 

     imul   eax, dword[Y], Field.Width
     add    eax, dword[X]
     mul    dword[Z]
     add    eax, Field.Blocks
     
     xchg   eax, edi
     movzx  eax, byte[BlockIndex]
     mov    [edi], al
     jmp    .Finish

.Finish:
     ret
endp

;              func Field.TestBounds
;    Input:  dWord X, dWord Y, dWord Z
;    Output: eax <- Zero or ErrorCode
;
proc Field.TestBounds X: dword, Y: dword, Z: dword
     xor    eax, eax

     cmp    dword[X], Field.Length
     jge    .Error

     cmp    dword[Y], Field.Width
     jge    .Error

     cmp    dword[Z], Field.Height
     jge    .Error

     cmp    dword[X], 0
     jl     .Error 
     cmp    dword[Y], 0
     jl     .Error
     cmp    dword[Z], 0
     jl     .Error
     jmp    .Finish

.Error:    
     mov    eax, ERROR_OUT_OF_BOUND    
.Finish:   
     ret
endp
